# Workflow to handle packaging the Unity SDK
name: Package SDKs

on:
  workflow_call:
    inputs:
      triggered_by_callable:
        description: 'Check if this package grabs artifacts from new build workflow'
        default: false
        required: true
        type: boolean
      skipIntegrationTests:
        description: 'skip integration tests?'
        default: '0'
        required: false
        type: string
      create_new_branch:
        description: 'Check if we need to create new branch to package guids update. If working_branch set, will ignore this value. '
        default: '0'
        required: false
        type: string
      working_branch:
        description: 'If already a working in progress release branch'
        required: false
        type: string
      release_label:
        description: 'If the package is intended to run for a release, put <version>-RC## for label'
        required: false
        type: string
      build_run_id:
        description: 'run id for build_starter.yml, search for all output'
        required: false
        type: string
      platforms:
        description: 'CSV of Android,iOS,Windows,macOS,Linux,Playmode'
        default: 'Android,iOS,Windows,macOS,Linux,Playmode'
        required: true
        type: string
      apis:
        description: 'CSV of apis to build and test'
        default: 'analytics,auth,crashlytics,database,dynamic_links,firestore,functions,installations,messaging,remote_config,storage'
        required: true
        type: string

  workflow_dispatch:
    inputs:
      use_new_build:
        description: 'Check if this package grabs artifacts from new build workflow'
        default: '0'
        required: true
      skipIntegrationTests:
        description: 'skip integration tests?'
        default: '0'
        required: false
      create_new_branch:
        description: 'Check if we need to create new branch to package guids update. If working_branch set, will ignore this value. '
        default: '0'
        required: false
      working_branch:
        description: 'If already a working in progress release branch'
        required: false
      release_label:
        description: 'If the package is intended to run for a release, put <version>-RC## for label'
        required: false
      download_ios_run:
        description: 'run id for ios.yml or build_starter.yml, search for ios_unity output'
        required: false
      download_android_run:
        description: 'run id for android.yml or build_starter.yml, search for android_unity output'
        required: false
      download_linux_run:
        description: 'run id for sdk_build.yml or build_starter.yml, search for linux_unity output'
        required: false
      download_macos_run:
        description: 'run id for sdk_build.yml or build_starter.yml, search for macos_unity output'
        required: false
      download_windows_run:
        description: 'run id for sdk_build.yml or build_starter.yml, search for windows_unity output'
        required: false


env:
  # Use SHA256 for hashing files.
  hashCommand: "sha256sum"

jobs:
  package_sdks:
    name: package-${{github.event.inputs.release_label}}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
    outputs:
      skipIntegrationTests: ${{ steps.decide_input.outputs.skipIntegrationTests }}
      platforms: ${{ steps.decide_input.outputs.platforms }}
      apis: ${{ steps.decide_input.outputs.apis }}
    steps:
      - name: Decide inputs
        id: decide_input
        shell: bash
        run: |
          if [[ "${{ inputs.triggered_by_callable }}" == "true" ]]; then
            # Triggered by callable
            echo "::set-output name=use_new_build::'1'"
            echo "::set-output name=workflow_conclusion::in_progress" 
            echo "::set-output name=skipIntegrationTests::${{ inputs.skipIntegrationTests }}"
            echo "::set-output name=create_new_branch::${{ inputs.create_new_branch }}"
            echo "::set-output name=release_label::${{ inputs.release_label }}"
            echo "::set-output name=working_branch::${{ inputs.working_branch }}"
            echo "::set-output name=download_android_run::${{ inputs.build_run_id }}"
            echo "::set-output name=download_ios_run::${{ inputs.build_run_id }}"
            echo "::set-output name=download_linux_run::${{ inputs.build_run_id }}"
            echo "::set-output name=download_macos_run::${{ inputs.build_run_id }}"
            echo "::set-output name=download_windows_run::${{ inputs.build_run_id }}"
            echo "::set-output name=platforms::${{ inputs.platforms }}"
            echo "::set-output name=apis::${{ inputs.apis }}"
          else
            echo "::set-output name=use_new_build::${{ github.event.inputs.use_new_build }}"
            echo "::set-output name=workflow_conclusion::success"
            echo "::set-output name=skipIntegrationTests::${{ github.event.inputs.skipIntegrationTests }}"
            echo "::set-output name=create_new_branch::${{ github.event.inputs.create_new_branch }}"
            echo "::set-output name=release_label::${{ github.event.inputs.release_label }}"
            echo "::set-output name=working_branch::${{ github.event.inputs.working_branch }}"
            echo "::set-output name=download_android_run::${{ github.event.inputs.download_android_run }}"
            echo "::set-output name=download_ios_run::${{ github.event.inputs.download_ios_run }}"
            echo "::set-output name=download_linux_run::${{ github.event.inputs.download_linux_run }}"
            echo "::set-output name=download_macos_run::${{ github.event.inputs.download_macos_run }}"
            echo "::set-output name=download_windows_run::${{ github.event.inputs.download_windows_run }}"
            echo "::set-output name=platforms::Android,iOS,Windows,macOS,Linux,Playmode"
            echo "::set-output name=apis::analytics,auth,crashlytics,database,dynamic_links,firestore,functions,installations,messaging,remote_config,storage"
          fi

      - name: Print inputs
        shell: bash
        run: |
          echo triggered_by_callable: ${{ inputs.triggered_by_callable }}
          echo use_new_build: ${{ steps.decide_input.outputs.use_new_build }}
          echo workflow_conclusion: ${{ steps.decide_input.outputs.workflow_conclusion }}
          echo skipIntegrationTests: ${{ steps.decide_input.outputs.skipIntegrationTests }}
          echo create_new_branch: ${{ steps.decide_input.outputs.create_new_branch }}
          echo release_label: ${{ steps.decide_input.outputs.release_label }}
          echo working_branch: ${{ steps.decide_input.outputs.working_branch }}
          echo download_android_run: ${{ steps.decide_input.outputs.download_android_run }}
          echo download_ios_run: ${{ steps.decide_input.outputs.download_ios_run }}
          echo download_linux_run: ${{ steps.decide_input.outputs.download_linux_run }}
          echo download_macos_run: ${{ steps.decide_input.outputs.download_macos_run }}
          echo download_windows_run: ${{ steps.decide_input.outputs.download_windows_run }}
          echo platforms: ${{ steps.decide_input.outputs.platforms }}"
          echo apis: ${{ steps.decide_input.outputs.apis }}"

      - name: Check out base branch
        uses: actions/checkout@v2.3.1
        with:
          fetch-depth: 0
          ref: ${{ steps.decide_input.outputs.working_branch }}

      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.7

      - name: Install python deps
        shell: bash
        run: |
          pip install -r scripts/gha/requirements.txt

      - name: Generate token for GitHub API
        # This step is necessary because the existing GITHUB_TOKEN cannot be used inside one workflow to trigger another.
        # 
        # Instead, generate a new token here, using our GitHub App's private key and App ID (saved as Secrets).
        # 
        # This method is preferred over the "personal access token" solution, as the GitHub App's scope is limited to just
        # the firebase-cpp-sdk repository.
        uses: tibdex/github-app-token@v1
        id: generate-token
        with:
          app_id: ${{ secrets.WORKFLOW_TRIGGER_APP_ID }}
          private_key: ${{ secrets.WORKFLOW_TRIGGER_APP_PRIVATE_KEY }}

      - name: Name new branch
        if: steps.decide_input.outputs.working_branch == '' && steps.decide_input.outputs.create_new_branch == '1'
        run: |
          date_str=$(date "+%Y%m%d-%H%M%S")
          echo "NEW_BRANCH=new_branch-${date_str}" >> $GITHUB_ENV

      - name: Create new branch
        if: steps.decide_input.outputs.working_branch == '' && steps.decide_input.outputs.create_new_branch == '1'
        run: |
          git remote update
          git checkout -b "${NEW_BRANCH}"
          echo "UPDATE_LOGFILE=update_log.txt" >> $GITHUB_ENV

      - name: Checkout working branch
        if: steps.decide_input.outputs.working_branch != ''
        run: |
          git remote update
          git checkout ${{ steps.decide_input.outputs.working_branch }}
          echo "UPDATE_LOGFILE=update_log.txt" >> $GITHUB_ENV
          echo "NEW_BRANCH=${{ steps.decide_input.outputs.working_branch }}" >> $GITHUB_ENV
      
      - name: Fetch Android Artifacts (OLD)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='0')
        with:
          workflow: android.yml
          run_id: ${{ steps.decide_input.outputs.download_android_run }}
          name: android_unity
          path: built_artifact
      
      - name: Fetch iOS Artifacts (OLD)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='0')
        with:
          workflow: ios.yml
          run_id: ${{ steps.decide_input.outputs.download_ios_run }}
          name: ios_unity
          path: built_artifact

      - name: Fetch Linux Artifacts (OLD)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='0')
        with:
          workflow: sdk_build.yml
          run_id: ${{ steps.decide_input.outputs.download_linux_run }}
          name: linux_unity
          path: built_artifact

      - name: Fetch MacOS Artifacts (OLD)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='0')
        with:
          workflow: sdk_build.yml
          run_id: ${{ steps.decide_input.outputs.download_macos_run }}
          name: macos_unity
          path: built_artifact

      - name: Fetch Windows Artifacts (OLD)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='0')
        with:
          workflow: sdk_build.yml
          run_id: ${{ steps.decide_input.outputs.download_windows_run }}
          name: windows_unity
          path: built_artifact

      - name: Fetch Android Artifacts (NEW)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='1')
        with:
          workflow: build_starter.yml
          run_id: ${{ steps.decide_input.outputs.download_android_run }}
          name: android_unity
          path: built_artifact
      
      - name: Fetch iOS Artifacts (NEW)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='1')
        with:
          workflow: build_starter.yml
          run_id: ${{ steps.decide_input.outputs.download_ios_run }}
          name: ios_unity
          path: built_artifact

      - name: Fetch Linux Artifacts (NEW)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='1')
        with:
          workflow: build_starter.yml
          run_id: ${{ steps.decide_input.outputs.download_linux_run }}
          name: linux_unity
          path: built_artifact

      - name: Fetch MacOS Artifacts (NEW)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='1')
        with:
          workflow: build_starter.yml
          run_id: ${{ steps.decide_input.outputs.download_macos_run }}
          name: macos_unity
          path: built_artifact

      - name: Fetch Windows Artifacts (NEW)
        uses: dawidd6/action-download-artifact@v2
        continue-on-error: true
        if: (inputs.triggered_by_callable==false) && (steps.decide_input.outputs.use_new_build=='1')
        with:
          workflow: build_starter.yml
          run_id: ${{ steps.decide_input.outputs.download_windows_run }}
          name: windows_unity
          path: built_artifact

      # If called by build_start.xml, ignore name search, just grab all artifact exists
      - name: Fetch All in build_starter
        uses: actions/download-artifact@v3
        if: inputs.triggered_by_callable==true
        with:
          path: built_artifact
      
      - name: move zip files
        run: |
          cd built_artifact
          find . -type f -name "*.zip" -exec mv {} . \;
          find . -empty -type d -delete
          ls -lR
          for zip_file in *.zip
          do
            unzip -l $zip_file
          done
          ls -lR
          cd ..

      - name: Package unitypackage
        run: |
          python scripts/build_scripts/build_package.py --zip_dir=built_artifact

      - name: Commit Changes if there is any
        if: steps.decide_input.outputs.working_branch != '' || steps.decide_input.outputs.create_new_branch == '1'
        run: |
          if ! git update-index --refresh; then
            git config user.email "firebase-workflow-trigger-bot@google.com"
            git config user.name "firebase-workflow-trigger-bot"
            git config core.commentChar "%"  # so we can use # in git commit messages
            git commit -a -m "Update Guids ID"

            # Show changes in git log
            git diff
            # Push branch
            git push --set-upstream origin "${NEW_BRANCH}"
          fi

      - name: Create PR if there is None
        if: steps.decide_input.outputs.working_branch != '' || steps.decide_input.outputs.create_new_branch == '1'
        id: push-branch
        run: |
          if ! git update-index --refresh; then
            date_str=$(date "+%a %b %d %Y")
            commit_title="Update Unity SDK dependencies - ${date_str}"
            commit_body=
            if [[ -n '${{ github.event.inputs.comment }}' ]]; then
              # If a comment was provided, start with that instead of blank.
              commit_body='${{ github.event.inputs.comment }}

            '
            fi

            commit_body="${commit_body}

          > Created by [${{github.workflow}} workflow]($GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)."
            git config user.email "firebase-workflow-trigger-bot@google.com"
            git config user.name "firebase-workflow-trigger-bot"
            git config core.commentChar "%"  # so we can use # in git commit messages
            git commit -a -m "${commit_title}

          ${commit_body}"
            echo "::set-output name=branch_pushed::1"
            # Show changes in git log
            git diff
            # Push branch
            git push --set-upstream origin "${NEW_BRANCH}"
            # Create pull request
            pr_number=$(python scripts/gha/create_pull_request.py --token ${{ steps.generate-token.outputs.token }} --head "${NEW_BRANCH}" --base "${{ github.event.inputs.baseBranch }}" --title "${commit_title}" --body "${commit_body}")
            echo "::set-output name=created_pr_number::${pr_number}"
          else
            echo "::warning ::No changes detected, won't create pull request."
            echo "::set-output name=branch_pushed::0"
          fi

      - name: Create Zip File
        run: |
          mv output firebase_unity_sdk
          cp docs/readme.md firebase_unity_sdk/.
          cp LICENSE firebase_unity_sdk/.
          ls -Rl firebase_unity_sdk
          zip -r firebase_unity_sdk.zip firebase_unity_sdk

      - name: compute SDK hash
        shell: bash
        run: |
          ${{ env.hashCommand }} --tag firebase_unity_sdk.zip >> firebase_unity_sdk_hash.txt
          echo "::warning ::$(cat firebase_unity_sdk_hash.txt)"

      - name: Upload Build unitypackage
        uses: actions/upload-artifact@v2
        with:
          name: firebase_unity_sdk.zip
          path: firebase_unity_sdk.zip
      
      - name: Package tgz
        run: |
          python scripts/build_scripts/build_package.py --zip_dir=built_artifact --output_upm=True --output=output_tgz

      - name: Listing output tgz
        run: |
          ls -Rl
        working-directory: output_tgz

      - name: compute SDK hash for tgz files
        shell: bash
        run: |
          tgz_files_list=$(find -type f -name '*.tgz')
          for tgz_file in "${tgz_files_list[@]}"; do
            ${{ env.hashCommand }} --tag ${tgz_file} >> ../firebase_unity_sdk_hash.txt
          done
          echo "::warning update sha txt \n ::$(cat ../firebase_unity_sdk_hash.txt)"
        working-directory: output_tgz

      - name: Upload Build tgz
        uses: actions/upload-artifact@v2
        with:
          name: firebase_unity_sdk_tgz
          path: output_tgz

      - name: upload hash
        uses: actions/upload-artifact@v2.2.2
        with:
          name: firebase_unity_sdk_hash.txt
          path: firebase_unity_sdk_hash.txt

  trigger_integration_tests:
    # Trigger the integration_tests workflow.
    needs: [package_sdks]
    if: (needs.package_sdks.outputs.skipIntegrationTests == '0') && !cancelled() && !failure()
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repo
      uses: actions/checkout@v2.3.1

    - name: Setup python
      uses: actions/setup-python@v2
      with:
        python-version: 3.7
    - name: Generate token for GitHub API
      # This step is necessary because the existing GITHUB_TOKEN cannot be used inside one workflow to trigger another.
      # 
      # Instead, generate a new token here, using our GitHub App's private key and App ID (saved as Secrets).
      # 
      # This method is preferred over the "personal access token" solution, as the GitHub App's scope is limited to just
      # the firebase-cpp-sdk repository.
      uses: tibdex/github-app-token@v1
      id: generate-token
      with:
        app_id: ${{ secrets.WORKFLOW_TRIGGER_APP_ID }}
        private_key: ${{ secrets.WORKFLOW_TRIGGER_APP_PRIVATE_KEY }}
    - name: Use GitHub API to start workflow
      shell: bash
      run: |
        pip install -r scripts/gha/requirements.txt
        if [[ "${{ github.event_name }}" == "schedule" ]]; then
          # reuse flag --test_pull_request=nightly-packaging to generate report
          generate_report=(-p test_pull_request nightly-packaging)
        fi
        set -e
        python scripts/gha/trigger_workflow.py \
          -t ${{ steps.generate-token.outputs.token }} \
          -w integration_tests.yml \
          -p test_packaged_sdk ${{ github.run_id }} \
          -p platforms ${{ needs.package_sdks.outputs.platforms }} \
          -p apis ${{ needs.package_sdks.outputs.apis }} \
          -s 10 -A -v
