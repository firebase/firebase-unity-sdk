// Copyright 2017 Google Inc. All Rights Reserved.
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Firebase
{
  // This class is intended only for tests to be run directly using mono.
  // API changes can be made directly to this class or if there are too many, this class
  // can be regenerated by running a decompiler (say resharper) on Firebase.App.dll in the unity package.
  // The decompiled code will have to be massaged quite a bit and all p/invokes removed, so this route
  // may take a lot longer than simple hand edits.
  public sealed class FirebaseApp : IDisposable
  {
    private static readonly Dictionary<string, FirebaseApp> NameToProxy = new Dictionary<string, FirebaseApp>();
    private static LogLevel _level;

    public static FirebaseApp DefaultInstance
    {
      get
      {
        return GetInstance(DefaultName) ?? Create();
      }
    }

    public string Name { get; private set; }

    public AppOptions Options { get; private set; }

    public static string DefaultName
    {
      get
      {
        return "DEFAULT";
      }
    }

    ~FirebaseApp()
    {
      Dispose();
    }

    public void Dispose()
    {
      lock (NameToProxy)
      {
        NameToProxy.Remove(Name);
      }
    }

    public static FirebaseApp GetInstance(string name)
    {
      lock (NameToProxy)
      {
        FirebaseApp local1;
        if (NameToProxy.TryGetValue(name, out local1))
          return local1;
        return null;
      }
    }

    public static FirebaseApp Create()
    {
      return CreateAndTrack(() => new FirebaseApp() { Options = new AppOptions(), Name = DefaultName });
    }

    public static FirebaseApp Create(AppOptions options)
    {
      return CreateAndTrack(() => new FirebaseApp() { Options = options, Name = DefaultName});
    }

    public static FirebaseApp Create(AppOptions options, string name)
    {
      return CreateAndTrack(() => new FirebaseApp() { Options = options, Name = name });
    }

    public static void SetLogLevel(LogLevel level)
    {
      SetLogLevelInternal(level);
    }

    public static LogLevel LogLevel
    {
      get { return _level; }
      set { _level = value; }
    }

    internal static void EmptyAppDictionaries()
    {
      lock (NameToProxy)
      {
        List<FirebaseApp> local1 = new List<FirebaseApp>(NameToProxy.Values);
        NameToProxy.Clear();
        foreach (FirebaseApp item0 in local1)
          item0.Dispose();
      }
    }

    internal static Uri UrlStringToUri(string urlString)
    {
      if (string.IsNullOrEmpty(urlString))
        return null;
      return new Uri(urlString);
    }

    internal static string UriToUrlString(Uri uri)
    {
      if (uri != null)
        return uri.OriginalString;
      return string.Empty;
    }

    internal Task<string> TokenAsync(bool forceRefresh) {
      return null;
    }

    internal static void LogMessage(Firebase.LogLevel logLevel,
      string message) {
      LogMessage(logLevel, null, message);
    }

    internal static Action<LogLevel, Uri, string> sLogger;

    internal static void LogMessage(Firebase.LogLevel logLevel,
      Uri context,
      string message) {
      if (sLogger != null)
      {
        sLogger(logLevel, context, message);
      }
    }

    private static FirebaseApp CreateAndTrack(CreateDelegate createDelegate)
    {
      Firebase.Mono.MonoPlatformServices.Install();

      lock (NameToProxy)
      {
        FirebaseApp createdInstance;
        try
        {
          createdInstance = createDelegate();
        }
        catch (ApplicationException exception0)
        {
          string exceptionMessage = exception0.Message;
          int exceptionSubString = exceptionMessage.IndexOf(":", StringComparison.Ordinal);
          if (exceptionSubString >= 0)
            throw new InitializationException((InitResult) int.Parse(exceptionMessage.Substring(0, exceptionSubString)),
                  exceptionMessage.Substring(exceptionSubString + 1));
          throw new InitializationException(InitResult.FailedMissingDependency, exceptionMessage);
        }
        NameToProxy[createdInstance.Name] = createdInstance;
        return createdInstance;
      }
    }

    public static DependencyStatus CheckDependencies()
    {
      InitResult initResult = InitResult.Success;
      FirebaseApp firebaseApp = null;
      EmptyAppDictionaries();
      try
      {
        firebaseApp = DefaultInstance;
      }
      catch (InitializationException ex)
      {
        initResult = ex.InitResult;
        if (initResult != InitResult.FailedMissingDependency)
          throw;
      }
      finally
      {
        if (firebaseApp != null)
          firebaseApp.Dispose();
      }
      if (initResult == InitResult.Success)
        return DependencyStatus.Available;
      return DependencyStatus.UnavailableOther;
    }

    internal static void SetLogLevelInternal(LogLevel level) {
      _level = level;
    }

    private delegate void DestroyDelegate();

    private delegate FirebaseApp CreateDelegate();

    internal static System.Threading.SynchronizationContext
        ThreadSynchronizationContext {
      get {
        return null;
      }
    }
  }
}
