/*
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef FIREBASE_STORAGE_CLIENT_UNITY_SRC_SWIG_MONITOR_CONTROLLER_H_
#define FIREBASE_STORAGE_CLIENT_UNITY_SRC_SWIG_MONITOR_CONTROLLER_H_

#include <assert.h>
#include <stdint.h>

#include "app/src/callback.h"
#include "app/src/include/firebase/internal/mutex.h"
#include "storage/src/include/firebase/storage.h"

// NOTE: We only define SWIGSTDCALL here so that this header can be built as
// a blaze library.  When used by a SWIG module (e.g storage.SWIG) SWIGSTDCALL
// is defined by the C++ generated by SWIG.
#ifndef SWIGSTDCALL
#define SWIGSTDCALL
#else
#endif

namespace firebase {
namespace storage {

// Monitors a storage stream and allows a user to control it.
class MonitorController : public Listener {
 public:
  // Function that references a C# delegate which is called from OnPaused()
  // or OnProgress().
  typedef void(SWIGSTDCALL* Event)(void* event_data);

 private:
  // Event function pointer guarded by a mutex.
  class EventState {
   public:
    explicit EventState(Mutex* mutex)
        : event_(nullptr), mutex_(mutex), reference_(nullptr) {}

    // Cancel this event if it's scheduled.
    ~EventState() { Cancel(); }

    // Get / set the callback associated with this class.
    Event event() const { return event_; }
    void set_event(Event event, void* event_data) {
      Cancel();
      event_ = event;
      event_data_ = event_data;
    }

    // Schedule this event to be called via callback::PollCallbacks() on a valid
    // C# thread if it's not already enqueued.
    void Schedule() {
      MutexLock lock(*mutex_);
      if (reference_) return;
      reference_ =
          callback::AddCallback(new callback::CallbackValue1<EventState*>(
              this, MonitorController::HandleEvent));
    }

    // If this event is scheduled, cancel it.
    void Cancel() {
      MutexLock lock(*mutex_);
      if (reference_) {
        callback::RemoveCallback(reference_);
        reference_ = nullptr;
      }
    }

    // Execute the callback associated with this event.
    void Execute() {
      {
        MutexLock lock(*mutex_);
        if (!reference_) return;
        reference_ = nullptr;
      }
      Event event_callback = event();
      if (event_callback) event_callback(event_data_);
    }

   private:
    Event event_;       // Event function.
    void* event_data_;  // Data to pass to event_.
    Mutex* mutex_;      // Mutex that controls access to this state.
    void* reference_;   // Reference to this object in the callback queue.
  };

 public:
  explicit MonitorController(StorageReference* storage_reference)
      : storage_reference_(storage_reference),
        paused_event_(&event_mutex_),
        progress_event_(&event_mutex_),
        bytes_transferred_(0),
        total_byte_count_(-1) {}

  ~MonitorController() {}

  // Set / change the paused event.
  void SetPausedEvent(Event event, void* event_data) {
    paused_event_.set_event(event, event_data);
  }

  // Set / change the progress event.
  void SetProgressEvent(Event event, void* event_data) {
    progress_event_.set_event(event, event_data);
  }

  // Get the Controller used to change the state of a stream.
  Controller* controller() { return &controller_; }

  // Get the bytes transferred at the last OnProgress() update.
  // The controller may be invalid by the time the callback is executed so use
  // this method to get the bytes transferred.
  int64_t bytes_transferred() const { return bytes_transferred_; }

  // Get the transfer size at the last OnProgress() update.
  // The controller may be invalid by the time the callback is executed so use
  // this method to get the transfer size.
  int64_t total_byte_count() const { return total_byte_count_; }

  // If monitor_controller is non-null return the associated controller, returns
  // nullptr otherwise.
  static Controller* GetController(MonitorController* monitor_controller) {
    return monitor_controller ? monitor_controller->controller() : nullptr;
  }

 private:
  // Called when a storage stream is paused.
  virtual void OnPaused(Controller* storage_reference_controller) {
    // WARNING: Due to b/68759166 the controller passed to this method is *not*
    // this instance.
    UpdateTransferState(storage_reference_controller);
    paused_event_.Schedule();
  }

  // Called when a storage stream reports a change in stream progress.
  virtual void OnProgress(Controller* storage_reference_controller) {
    // WARNING: Due to b/68759166 the controller passed to this method is *not*
    // this instance.
    UpdateTransferState(storage_reference_controller);
    progress_event_.Schedule();
  }

  // Cache the transfer state from the controller.
  void UpdateTransferState(Controller* storage_reference_controller) {
    bytes_transferred_ = storage_reference_controller->bytes_transferred();
    total_byte_count_ = storage_reference_controller->total_byte_count();
  }

 private:
  // Called via callback::PollCallbacks() to dispatch a call to the
  // paused_callback_ C# delegate on a valid thread.
  static void HandleEvent(EventState* state) {
    EventState* event_state = static_cast<EventState*>(state);
    event_state->Execute();
  }

 protected:
  StorageReference* storage_reference_;
  // Controls an ongoing upload / download operation.
  Controller controller_;
  Mutex event_mutex_;
  EventState paused_event_;
  EventState progress_event_;
  // Cache of the transfer state on the last OnProgress() or OnPause() event.
  int64_t bytes_transferred_;
  int64_t total_byte_count_;
};

}  // namespace storage
}  // namespace firebase

#endif  // FIREBASE_STORAGE_CLIENT_UNITY_SRC_SWIG_MONITOR_CONTROLLER_H_
